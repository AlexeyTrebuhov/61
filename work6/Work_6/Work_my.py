# 2.	Добавьте в пакет, созданный на семинаре шахматный модуль. Внутри него напишите код, решающий задачу о 8 ферзях.
# Известно, что на доске 8×8 можно расставить 8 ферзей так, чтобы они не били друг друга. Вам дана расстановка 8 ферзей
# на доске, определите, есть ли среди них пара бьющих друг друга. Программа получает на вход восемь пар чисел, каждое
# число от 1 до 8 - координаты 8 ферзей. Если ферзи не бьют друг друга верните истину, а если бьют - ложь.
# 3.	Напишите функцию в шахматный модуль. Используйте генератор случайных чисел для случайной расстановки ферзей в
# задаче выше. Проверяйте различный случайные варианты и выведите 4 успешных расстановки.

from random import randint
from random import shuffle
import random

mas = []
nums = [0,0,0,0,0,0,0,1]
count = 0 # счетчик ферзей по вертикали
total_count = 0 # тотальный счетчик вертикалей с одним ферзем из числа всех вертикалей игрового поля
brutal_count = 0 # счетчик всех попыток рандомной расстановки
super_brutal_count = 0 # число удачных совпадений
b = 8 # размер игрового поля
item = int(input('Сколько удачных попыток вывести на печать ? '))


while super_brutal_count < item:
    while total_count < b:

        # Создали поле, в котором на каждой горизонтали стоит один ферзь


        r = [ 0,0,0,0,0,0,0,1]  #  по умолчанию на одной горизонтали всегда есть один ферзь
        mas = []
        for i in range(b):
            mas.append([])
            random.shuffle(r)

            for j in range(b):
                mas[i].append(r[j]) # создали b рандомных строк с одним ферзем

        # поскольку по горизонтали стоит по одному ферзю, нужно проверить вертикаль
        for i in range(b):
            for i2 in range(0, len(mas[i])):
                count = count + mas[i2][i]

            if count <= 1 : # при этом условии на выбранной вертикали второго ферзя нет
                count = 0 # обнуляем счетчик подсчета ферзей, расположенных на выбранной вертикали
                total_count = total_count + 1   # считаем количество вертикалей с одним ферзем из
                # общего числа вертикалей игрового поля


            else:   # При этом условии на выбранной вертикали нашли второго ферзя
                count = 0 # обнуляем счетчик подсчета ферзей, расположенных на выбранной вертикали

        brutal_count = brutal_count + 1 # в этом месте получили одно игровое поле, проверенное на совпадение наличия
        # нескольких ферзей по всем имеющимся вертикалям. Независимо от результата,
        # увеличиваем счетчик проверенных полей на единицу

        if total_count == b:  # Если на всех вертикалях игрового поля стоит только по одному ферзю, то
            print("_"*50)
            print("Номер успешной попытки при рандомной расстановке  = " , brutal_count)
            super_brutal_count = super_brutal_count + 1  # Счетчик удачных попыток увеличиваем на единицу

            for i in range(0, len(mas)):  # Выводим на печать картинку успешного рандома
                for i2 in range(0, len(mas[i])):
                    print(mas[i][i2] , end=' ')
                print ()

        else:  # Если на какой-то вертикали есть второй ферзь, уходим в начало цикла на новую попытку расстановки
            pass


        if super_brutal_count == item: # Срабатывание ограничения счетчика удачных попыток
            break

        total_count = 0  # Перед новым рандомом обнуляем счетчик числа вертикалей с одним ферзем

